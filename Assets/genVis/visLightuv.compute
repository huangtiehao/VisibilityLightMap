// // Each #kernel tells which function to compile; you can have many kernels
// #pragma kernel CSMain
// #ifndef CUSTOM_VOXEL_PASS_INCLUDED
// #define CUSTOM_VOXEL_PASS_INCLUDED
//
// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
// #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
// #define EPS 0.01
// #define STEPS 64
// struct Triangle {
//     float3 a, b, c;
// };
//
// RWTexture2D<float4>SH;
// uint triangleCnt;
// StructuredBuffer<Triangle> triangles;
//
// // sampler3D SDF_tex;
//
// TEXTURE2D(_BaseMap);
// SAMPLER(sampler_BaseMap);
//
// // float3 _MinExtents;
// // float3 _MaxExtents;
// // float3 _Center;
//
// float SHfunction(int i,in float3 s) 
// { 
//     #define k01 0.2820947918    // sqrt(  1/PI)/2
//     #define k02 0.4886025119    // sqrt(  3/PI)/2
//     #define k03 1.0925484306    // sqrt( 15/PI)/2
//     #define k04 0.3153915652    // sqrt(  5/PI)/4
//     #define k05 0.5462742153    // sqrt( 15/PI)/4
//
//     //float3 n = s.zxy;
//     float x = s.x;
//     float y = s.z;
//     float z = s.y;
// 	
//     //----------------------------------------------------------
//     if( i==0 ) return  k01;
//     //----------------------------------------------------------
//     if( i==1 ) return  k02*y;
//     if( i==2 ) return  k02*z;
//     if( i==3 ) return  k02*x;
//     //----------------------------------------------------------
//     if( i==4 ) return  k03*x*y;
//     if( i==5 ) return  k03*y*z;
//     if( i==6 ) return  k04*(2.0*z*z-x*x-y*y);
//     if( i==7 ) return  k03*x*z;
//     if( i==8 ) return  k05*(x*x-y*y);
//
//     return 0.0;
// }
//
// // float3 Remap(float3 v, float3 fromMin, float3 fromMax, float3 toMin, float3 toMax) {
// //     return (v-fromMin)/(fromMax-fromMin)*(toMax-toMin)+toMin;
// // }
// //       
// // float3 LocalPosToUVW(float3 localPos) {
// //     return Remap(localPos-_Center, _MinExtents, _MaxExtents, 0, 1);
// // }
//       
//
//
// struct Attributes
// {
//     float4 positionOS : POSITION;
//     float4 normalOS: NORMAL;
//     float2 baseUV : TEXCOORD0;
// };
//
// struct Varyings
// {
//     float4 positionCS :SV_POSITION;
//     float3 positionWS : VAR_POSITION;
//     float3 normalWS: VAR_NORMAL;
//     float2 baseUV : VAR_BASE_UV;
// };
//
//
//
// Attributes VoxelPassVertex(Attributes input)
// {
//     Varyings output;
//     output.positionWS=TransformObjectToWorld(input.positionOS);
//     output.positionCS=TransformWorldToHClip(output.positionWS);
//     output.normalWS=TransformObjectToWorldNormal(input.normalOS);
//     output.baseUV=input.baseUV;
//     return input;
//
//      // Varyings output;
//      // output.positionWS.xyz=TransformObjectToWorld(input.positionOS);
//      // output.positionCS=TransformWorldToHClip(output.positionWS);
//      // float4 viewPos=mul(VX,float4(output.positionWS.xyz,1));
//      // //float4 viewPos=float4(TransformWorldToView(output.positionWS),1.0);
//      // //output.positionCS=TransformWViewToHClip(viewPos);
//      // output.positionCS = mul(PX,viewPos); 
//      // return output;
//     
// }
// struct Ray
// {
//     float3 orig;
//     float3 dir;
// };
//
// bool hitTriangle(Triangle tri, Ray ray)
// {
//
//     float3 p1 = tri.a;
//     float3 p2 = tri.b;
//     float3 p3 = tri.c;
//
//     float3 S = ray.orig;    // 射线起点
//     float3 d = ray.dir;     // 射线方向
//     float3 N = normalize(cross(p2-p1, p3-p1));    // 法向量
//     
//     if (abs(dot(N, d)) < 0.00001f) return false;
//
//     // 距离
//     float t = (dot(N, p1) - dot(S, N)) / dot(d, N);
//     if (t < 0.0005f) return false;    // 如果三角形在光线背面
//
//     // 交点计算
//     float3 P = S + d * t;
//
//     // 判断交点是否在三角形中
//     float3 c1 = cross(p2 - p1, P - p1);
//     float3 c2 = cross(p3 - p2, P - p2);
//     float3 c3 = cross(p1 - p3, P - p3);
//     bool r1 = (dot(c1, N) > 0 && dot(c2, N) > 0 && dot(c3, N) > 0);
//     bool r2 = (dot(c1, N) < 0 && dot(c2, N) < 0 && dot(c3, N) < 0);
//
//     // 命中，封装返回结果
//     if (r1 || r2) {
//         return true;
//     }
//     return false;
// }
//
//
// float getVisTri(Ray ray)
// {
//     for(int i=0;i<triangleCnt;++i)
//     {
//         if(hitTriangle(triangles[i],ray))return 1; 
//     }
//     return 0;
// }
// // float getVisSdf(float3 orig,float3 dir)
// // {
// //     float3 posOS=TransformWorldToObject(orig);
// //     float3 dirOS=TransformWorldToObject(dir);
// //     posOS+=2*EPS*dirOS;
// //     [unroll(STEPS)]
// //     for (uint j = 0; j < STEPS; j++)
// //     {
// //         float3 texcoord = LocalPosToUVW(posOS);
// //         float4 samp = tex3D(SDF_tex, texcoord);
// //         if (texcoord.x < 0.0 || texcoord.x > 1.0||texcoord.y < 0.0 || texcoord.y > 1.0||texcoord.z < 0.0 || texcoord.z > 1.0)
// //         {
// //             return 0;
// //         }
// //         float sdf=samp.r;
// //         //rayMarch
// //         posOS+=sdf*dirOS;
// //         //小于某个阈值就当作击中
// //         if(abs(sdf)<EPS)
// //         {
// //             return 1;
// //         }
// //     }
// //     return 0;
// // }
//
// float4 integ(float3 normal,float3 worldPos)
// {
//     float3 N = normalize(normal);
//
//     float4 ans=0;   
//     
//     // tangent space calculation from origin point
//     float3 up = abs(N.z) < 0.999 ? float3(0.0, 0.0, 1.0) : float3(1.0, 0.0, 0.0);
//     float3 right = normalize(cross(up, N));
//     up = normalize(cross(N, right));
//        
//     float sampleDelta = 0.1;
//     float nrSamples = 0.0;
//     for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta)
//     {
//         for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta)
//         {
//             // spherical to cartesian (in tangent space)
//             float3 tangentSample = float3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));
//             // tangent space to world
//
//             float3 worldDir=tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; 
//             Ray ray;
//             ray.orig=worldPos;
//             ray.dir=worldDir;
//             float v=getVisTri(ray);
//             for(int i=0;i<4;++i)
//             {
//                 ans[i]+= v*SHfunction(i,worldDir)*cos(theta) * sin(theta);
//             }
//
//             //irradiance += texture(cubeMap, sampleVec).rgb * cos(theta) * sin(theta);
//         }
//     }
//     return ans;
//     //return ans;
// }
//
// float4 VoxelPassFragment (Varyings input):SV_TARGET
// {
//     //return float4(0.0f,0.0f,1.0f,1.0f);
//     //SH[input.baseUV]=integ(input.normalWS,0,input.positionWS);
//     SH[input.baseUV]=float4(0.0,0.0,1.0f,1.0f);
//     return integ(input.normalWS,input.positionWS);;
// }
// // Create a RenderTexture with enableRandomWrite flag and set it
// // with cs.SetTexture
// RWTexture2D<float4> Result;
//
// [numthreads(8,8,1)]
// void CSMain (uint3 id : SV_DispatchThreadID)
// {
//     // TODO: insert actual code here!
//
//     Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
// }
